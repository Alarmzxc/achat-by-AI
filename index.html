<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Chat</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%230078D7' d='M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10s10-4.477 10-10S17.523 2 12 2zm-.811 3.81a1.764 1.764 0 0 0-1.25-.511c-.696 0-1.25.555-1.25 1.25c0 .22.06.428.158.614l3.342 3.342c.186-.098.394-.158.614-.158c.695 0 1.25.555 1.25 1.25c0 .22-.06.428-.158.614l-3.342 3.342a1.757 1.757 0 0 0-.614.158c-.696 0-1.25.555-1.25 1.25s.554 1.25 1.25 1.25a1.764 1.764 0 0 0 1.25-.511l5.14-5.141a1.764 1.764 0 0 0 1.25-.511c.696 0 1.25-.555 1.25-1.25s-.554-1.25-1.25-1.25a1.764 1.764 0 0 0-1.25-.511L11.19 5.81z'/%3E%3C/svg%3E" type="image/svg+xml">
    <style>
        /* Basic Reset and Body Styling */
        body {
            margin: 0;
            font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; /* Windows-like font stack */
            line-height: 1.6;
            /* 天蓝色渐变背景 */
            background: linear-gradient(to bottom right, #87CEEB, #E0FFFF); /* From SkyBlue to LightCyan */
            color: #333;
            display: flex;
            justify-content: center; /* Center the window horizontally */
            align-items: center; /* Center the window vertically */
            min-height: 100vh; /* Ensure body fills the viewport height */
            padding: 20px; /* Add padding around the window */
            box-sizing: border-box;
            overflow: auto; /* Allow body scroll if window is too large */
        }

        /* The "Window" Container */
        .window-container {
            width: 100%;
            max-width: 800px; /* Max width for desktop */
            height: 90vh; /* Max height of the window */
            max-height: 900px;
            background-color: rgba(255, 255, 255, 0.7); /* Semi-transparent white */
            backdrop-filter: blur(20px); /* Glassmorphism blur effect */
            -webkit-backdrop-filter: blur(20px); /* Safari support */
            border-radius: 16px; /* Rounded corners */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); /* Prominent shadow */
            border: 1px solid rgba(255, 255, 255, 0.18); /* Subtle border */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Ensure internal content respects border-radius */
            position: relative; /* Needed for absolute positioning inside */
        }

         /* Fallback for browsers that don't support backdrop-filter */
         @supports not (backdrop-filter: blur(20px)) {
             .window-container {
                 background-color: rgba(255, 255, 255, 0.95); /* Less transparency if blur isn't supported */
             }
         }


        /* Header (Title Bar) */
        .window-header {
            padding: 12px 20px;
            background-color: rgba(255, 255, 255, 0.5); /* Slightly more opaque than main window */
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            text-align: center;
            font-size: 1.1rem;
            font-weight: 600; /* Semi-bold */
            color: #2d2d2d; /* Darker text */
            flex-shrink: 0; /* Prevent header from shrinking */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Settings Toggle Button */
        .settings-toggle {
            position: absolute; /* Position relative to window-container */
            top: 10px;
            right: 15px;
            padding: 5px 10px;
            background: none;
            border: none;
            color: #0078D7; /* Win11 accent blue */
            font-size: 0.9rem;
            cursor: pointer;
            transition: color 0.2s ease, background-color 0.2s ease;
            border-radius: 6px; /* Small roundness */
            z-index: 10; /* Ensure it's above other content */
        }
        .settings-toggle:hover {
            color: #0056b3;
            background-color: rgba(0, 120, 215, 0.1); /* Subtle hover background */
        }
         .settings-toggle:focus {
             outline: none;
             box-shadow: 0 0 0 2px rgba(0, 120, 215, 0.3); /* Focus ring */
         }


        /* Settings Panel */
        .settings-panel {
            padding: 15px 20px;
            background-color: rgba(255, 255, 255, 0.8); /* Slightly more opaque */
             border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05); /* Subtle shadow below */
            display: none; /* Initially hidden */
            overflow-y: auto; /* Allow settings to scroll */
            max-height: 40%; /* Limit height relative to window */
            flex-shrink: 0;
        }
        .settings-panel h2 {
            margin-top: 0;
            font-size: 1.0rem;
            color: #555;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .settings-panel label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.9rem;
            color: #555;
        }
        .settings-panel select,
        .settings-panel input[type="number"],
        .settings-panel .favorites-list {
            width: calc(100% - 20px); /* Adjust for padding */
            padding: 8px 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 6px; /* Rounded corners */
            font-size: 0.9rem;
            box-sizing: border-box;
            background-color: #f9f9f9; /* Light background */
        }
         .settings-panel select {
             /* Custom arrow might be needed for full Win11 look */
         }
         .settings-panel input[type="number"]:focus,
         .settings-panel select:focus {
             outline: none;
             border-color: #0078D7;
             box-shadow: 0 0 0 2px rgba(0, 120, 215, 0.3);
             background-color: #fff;
         }

        .favorites-list {
            margin-top: 10px;
            max-height: 120px; /* Limit height */
            overflow-y: auto;
            border: 1px solid #ddd; /* More subtle border */
            padding: 8px;
            border-radius: 6px;
            background-color: #fff; /* White background for list */
        }
         .favorites-list div {
            margin-bottom: 5px;
            font-size: 0.9rem;
            display: flex; /* Align checkbox and label */
            align-items: center;
         }
         .favorites-list input[type="checkbox"] {
             margin-right: 8px;
             border-radius: 4px; /* Subtle rounded checkbox */
             width: 16px; /* Standard size */
             height: 16px;
             flex-shrink: 0; /* Prevent shrinking */
         }
         .favorites-list label {
              margin-bottom: 0;
              font-weight: normal;
              color: #333;
              cursor: pointer; /* Indicate clickable */
         }


        .settings-panel .clear-buttons button {
            margin-right: 10px;
            padding: 8px 15px;
            border: none;
            border-radius: 6px; /* Rounded buttons */
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s ease, opacity 0.2s ease;
        }
        .settings-panel .clear-buttons .clear-history { background-color: #ff9800; color: white; }
        .settings-panel .clear-buttons .clear-favorites { background-color: #f44336; color: white; }
        .settings-panel .clear-buttons button:hover { opacity: 0.9; }
         .settings-panel .clear-buttons button:active { opacity: 0.7; } /* Press effect */


        /* Chat Container */
        .chat-container {
            flex-grow: 1; /* Takes up available space */
            overflow-y: auto; /* Enable scrolling */
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: rgba(240, 240, 240, 0.6); /* Lighter background for chat area */
             /* Custom Scrollbar (Optional - Webkit browsers) */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #ccc transparent; /* Firefox */
        }
         .chat-container::-webkit-scrollbar {
             width: 8px;
         }
         .chat-container::-webkit-scrollbar-track {
             background: transparent; /* Make track transparent */
         }
         .chat-container::-webkit-scrollbar-thumb {
             background-color: rgba(0, 0, 0, 0.2); /* Semi-transparent thumb */
             border-radius: 4px;
             border: 2px solid transparent; /* Space around thumb */
             background-clip: content-box; /* Include padding in background */
         }
          .chat-container::-webkit-scrollbar-thumb:hover {
              background-color: rgba(0, 0, 0, 0.3);
          }


        /* Message Bubbles */
        .message {
            padding: 12px 15px;
            border-radius: 12px; /* Slightly less rounded */
            max-width: 85%;
            word-wrap: break-word;
            white-space: pre-wrap;
            line-height: 1.5;
            filter: drop-shadow(0 1px 0.5px rgba(0, 0, 0, 0.08)); /* Subtle shadow for bubbles */
        }

        .message.user {
            background-color: #0078D7; /* Win11 accent blue */
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px; /* Small tail */
        }

        .message.assistant {
            background-color: #ffffff;
            color: #333;
            align-self: flex-start;
            border: 1px solid #eee; /* Lighter border */
            border-bottom-left-radius: 4px; /* Small tail */
             margin-right: 20px;
        }
         .message.error {
             /* General error style */
             filter: drop-shadow(0 1px 0.5px rgba(255, 0, 0, 0.2));
         }
         .message.user.error {
             background-color: #d32f2f; /* Darker red for user errors */
         }
         .message.assistant.error {
             background-color: #ffcdd2; /* Lighter red for assistant errors */
             color: #c62828;
             border-color: #ef9a9a;
         }


        /* Input Area */
        .input-area {
            display: flex;
            padding: 15px 20px;
            background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent */
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            gap: 10px;
            align-items: flex-end;
            flex-shrink: 0;
        }

        #message-input {
            flex-grow: 1;
            padding: 10px 15px; /* Adjust padding */
            border: 1px solid #ccc;
            border-radius: 24px; /* More rounded (pill-like) */
            font-size: 1rem;
            resize: none;
            min-height: 40px; /* Explicit min-height */
            max-height: 120px; /* Limit height */
            overflow-y: auto;
            box-sizing: border-box;
            background-color: #fff; /* White background */
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        #message-input:focus {
             outline: none;
             border-color: #0078D7;
             box-shadow: 0 0 0 2px rgba(0, 120, 215, 0.3);
        }

        #send-button {
            padding: 10px 20px;
            background-color: #0078D7; /* Win11 accent blue */
            color: white;
            border: none;
            border-radius: 24px; /* More rounded (pill-like) */
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease, opacity 0.2s ease;
            min-width: 80px; /* Prevent button from shrinking too much */
        }
        #send-button:hover {
            background-color: #0056b3;
        }
         #send-button:active {
             background-color: #004494; /* Darker on press */
         }
        #send-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Status Area */
        #status-area {
            padding: 10px 20px;
            background-color: #fff3e0;
            color: #c67b00; /* Darker orange */
            font-size: 0.9rem;
            text-align: center;
             border-top: 1px solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
             display: none; /* Initially hidden */
        }
         #status-area.error {
            background-color: #ffebee;
            color: #c62828;
             border-top: 1px solid rgba(255, 255, 255, 0.3);
         }


        /* Markdown Styling (for assistant messages) */
        .message.assistant pre {
            background-color: #eef2f6; /* Light blue-ish code background */
            padding: 10px;
            border-radius: 6px;
            overflow-x: auto;
            margin-top: 10px;
            margin-bottom: 10px;
             line-height: 1.4;
             font-size: 0.9em;
             font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
        }
         .message.assistant code {
             font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
             background-color: #e0e0e0;
             padding: 2px 4px;
             border-radius: 4px;
             font-size: 0.9em;
         }
         .message.assistant pre code { /* Reset inline code style within pre */
             background-color: transparent;
             padding: 0;
             border-radius: 0;
             font-size: inherit;
         }

        .message.assistant p {
             margin-top: 0;
             margin-bottom: 10px;
             /* Override potential default margins from markdown lib */
             padding-top: 0;
             padding-bottom: 0;
        }
         .message.assistant p:last-child {
             margin-bottom: 0;
         }

        .message.assistant ul,
        .message.assistant ol {
            margin-top: 10px;
            margin-bottom: 10px;
            padding-left: 25px; /* Slightly more indent */
        }
         .message.assistant li {
             margin-bottom: 5px;
         }

        .message.assistant blockquote {
            border-left: 4px solid #0078D7; /* Accent color for blockquotes */
            padding-left: 15px;
            color: #555; /* Darker gray */
            margin: 10px 0;
            font-style: italic;
        }

         .message.assistant table {
             border-collapse: collapse;
             margin: 10px 0;
             width: auto; /* Prevent table from forcing full width */
             max-width: 100%; /* Ensure it doesn't exceed bubble width */
         }
         .message.assistant th,
         .message.assistant td {
             border: 1px solid #ddd;
             padding: 8px;
             text-align: left;
             word-break: break-word; /* Break long text in cells */
         }
         .message.assistant th {
             background-color: #f0f0f0;
             font-weight: 600;
         }


         /* Responsive Adjustments */
         @media (max-width: 820px) {
             .window-container {
                 width: 95%;
                 height: 95vh;
             }
         }

         @media (max-width: 600px) {
             body { padding: 10px; } /* Reduce body padding */
             .window-container {
                 border-radius: 8px; /* Less rounded corners on small screens */
                 height: 100vh; /* Full height on small screens */
                  max-height: none;
             }
             .window-header {
                 font-size: 1rem;
                 padding: 10px 15px;
             }
             .settings-toggle {
                 top: 8px;
                 right: 10px;
                 padding: 3px 8px;
                 font-size: 0.8rem;
             }
             .settings-panel {
                 padding: 10px 15px;
             }
             .settings-panel h2 {
                  font-size: 1rem;
                  padding-bottom: 5px;
                  margin-bottom: 10px;
             }
             .settings-panel label,
             .settings-panel select,
             .settings-panel input[type="number"],
              .settings-panel .favorites-list {
                  font-size: 0.85rem;
                  margin-bottom: 10px;
             }
             .settings-panel select,
             .settings-panel input[type="number"],
             .settings-panel .favorites-list {
                  padding: 6px 8px;
                  width: calc(100% - 16px);
             }
              .favorites-list {
                  max-height: 80px;
              }
             .settings-panel .clear-buttons button {
                 padding: 6px 10px;
                 font-size: 0.85rem;
                 margin-right: 5px;
             }

             .chat-container {
                 padding: 15px;
                 gap: 10px;
             }
             .message {
                 padding: 10px 12px;
                 border-radius: 10px;
                 max-width: 98%; /* Allow messages to be wider */
                  margin-right: 10px;
             }
             .message.assistant {
                 margin-right: 10px; /* Reduce margin on small screens */
             }
             .input-area {
                 padding: 10px 15px;
                 gap: 8px;
             }
             #message-input {
                 padding: 8px 12px;
                 border-radius: 20px;
                 min-height: 35px;
             }
             #send-button {
                 padding: 8px 15px;
                 border-radius: 20px;
                 font-size: 0.9rem;
                 min-width: 60px;
             }
             #status-area {
                 padding: 8px 15px;
                 font-size: 0.85rem;
             }
         }

    </style>
    <!-- Include marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
     <!-- Include DOMPurify for sanitizing Markdown output -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
</head>
<body>

    <div class="window-container">
        <div class="window-header">LLM Chat</div>

        <button class="settings-toggle" onclick="toggleSettings()" id="settings-toggle-button">设置选项 ▼</button>

        <div class="settings-panel" id="settings-panel">
            <h2>设置</h2>
            <div>
                <label for="model-select">选择模型:</label>
                <select id="model-select">
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <div>
                <label>收藏模型:</label>
                <div id="favorites-list" class="favorites-list">
                    <!-- Favorites will be populated by JavaScript -->
                </div>
            </div>
            <div>
                <label for="temperature">温度 (Temperature):</label>
                <input type="number" id="temperature" value="0.7" min="0" max="2" step="0.1" title="控制输出的随机性，值越高越随机，越低越确定。">
            </div>
             <div>
                <label for="max-tokens">最大输出长度 (Max Tokens):</label>
                <input type="number" id="max-tokens" value="500" min="1" title="模型生成的最大 token 数量。">
            </div>
            <div class="clear-buttons">
                <button class="clear-history" onclick="clearChatHistory()">清除聊天记录 (保留3个月内)</button>
                <button class="clear-favorites" onclick="clearFavorites()">清除收藏模型</button>
            </div>
        </div>

        <div id="chat-container" class="chat-container">
            <!-- Chat messages will be added here -->
        </div>

        <div class="input-area">
            <textarea id="message-input" placeholder="输入你的消息..." rows="1"></textarea>
            <button id="send-button">发送</button>
        </div>

        <div id="status-area" class="status-area">
            <!-- Status or error messages -->
        </div>
    </div>


    <script>
        const CHAT_STORAGE_KEY = 'llm_chat_history';
        const FAVORITES_STORAGE_KEY = 'llm_favorite_models';
        const WORKER_API_BASE = '/api'; // Cloudflare Worker route base
        const THREE_MONTHS_MS = 3 * 30 * 24 * 60 * 60 * 1000; // Rough estimate for 3 months

        let chatHistory = [];
        let favoriteModels = [];
        let availableModels = []; // Store fetched models

        // Configure marked.js (optional, defaults are usually fine)
        // marked.setOptions({
        //     gfm: true, // Use GitHub flavored markdown
        //     breaks: true, // Add <br> on a single newline
        //     // highlight: function(code, lang) { /* Add syntax highlighting library here if needed */ return code; },
        // });


        // --- Local Storage Management ---

        function loadChatHistory() {
            const historyJson = localStorage.getItem(CHAT_STORAGE_KEY);
            if (historyJson) {
                try {
                    chatHistory = JSON.parse(historyJson);
                     // Ensure timestamps exist and are numbers for filtering
                    chatHistory.forEach(msg => {
                        if (!msg.timestamp || typeof msg.timestamp !== 'number') {
                             // Attempt to parse if it's a string date, otherwise set to now
                            try {
                                const date = new Date(msg.timestamp);
                                msg.timestamp = isNaN(date.getTime()) ? Date.now() : date.getTime();
                            } catch (e) {
                                msg.timestamp = Date.now(); // Fallback
                            }
                        }
                         // Add role if missing (for very old formats)
                         if (!msg.role) msg.role = 'assistant'; // Guessing default role if missing
                    });
                    clearOldMessages(); // Clear old messages on load
                } catch (e) {
                    console.error("Failed to parse chat history from localStorage", e);
                    chatHistory = []; // Start fresh if corrupted
                }
            } else {
                chatHistory = [];
            }
        }

        function saveChatHistory() {
            localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(chatHistory));
        }

        function clearOldMessages() {
            const now = Date.now();
            // Filter out messages older than 3 months
            const threeMonthsAgo = now - THREE_MONTHS_MS;
            const newHistory = chatHistory.filter(msg => {
                 // Handle potential invalid timestamps gracefully
                 const msgTimestamp = msg.timestamp || now; // Use 'now' if timestamp is missing/invalid
                 return (now - msgTimestamp) < THREE_MONTHS_MS;
            });


            if (newHistory.length < chatHistory.length) {
                console.log(`Cleared ${chatHistory.length - newHistory.length} old messages.`);
                chatHistory = newHistory;
                saveChatHistory(); // Save after clearing
                // Optionally re-display after clearing old messages
                // displayChatHistory();
            }
        }

        function loadFavorites() {
            const favoritesJson = localStorage.getItem(FAVORITES_STORAGE_KEY);
            if (favoritesJson) {
                try {
                    favoriteModels = JSON.parse(favoritesJson);
                    // Ensure favoriteModels is an array of strings
                    if (!Array.isArray(favoriteModels)) favoriteModels = [];
                    else favoriteModels = favoriteModels.filter(fav => typeof fav === 'string');

                } catch (e) {
                    console.error("Failed to parse favorites from localStorage", e);
                    favoriteModels = []; // Start fresh
                }
            } else {
                favoriteModels = [];
            }
        }

        function saveFavorites() {
            localStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(favoriteModels));
        }

        function clearChatHistory() {
             if (confirm("确定要清除所有聊天记录吗？（3个月前的记录会自动清除，此操作会立即清除所有记录）")) {
                chatHistory = [];
                saveChatHistory();
                displayChatHistory();
                alert("聊天记录已清除。");
             }
        }

        function clearFavorites() {
             if (confirm("确定要清除收藏模型列表吗？")) {
                favoriteModels = [];
                saveFavorites();
                renderFavoritesList(); // Re-render the favorites list UI
                populateModelSelect(); // Update dropdown as well
                alert("收藏模型列表已清除。");
             }
        }

        // --- UI Rendering ---

        function displayMessage(message) {
            const chatContainer = document.getElementById('chat-container');
            const msgElement = document.createElement('div');
            msgElement.classList.add('message', message.role); // 'user' or 'assistant'

            if (message.role === 'assistant') {
                 // Render assistant messages as Markdown
                 try {
                     // Sanitize potential HTML before rendering Markdown using DOMPurify
                     const cleanContent = DOMPurify.sanitize(message.content);
                     msgElement.innerHTML = marked.parse(cleanContent);
                 } catch (e) {
                     console.error("Markdown rendering failed:", e);
                     msgElement.textContent = message.content; // Fallback to plain text
                 }
                 if (message.content.startsWith('[错误]')) {
                      msgElement.classList.add('error'); // Add error class for styling
                 }
            } else {
                // Render user messages as plain text (safer)
                msgElement.textContent = message.content;
                 if (message.content.startsWith('[错误]')) {
                      msgElement.classList.add('error'); // Add error class for styling
                 }
            }

            chatContainer.appendChild(msgElement);
            // Auto-scroll to the latest message smoothly
            chatContainer.scrollTo({
                top: chatContainer.scrollHeight,
                behavior: 'smooth'
            });
        }

        function displayChatHistory() {
            const chatContainer = document.getElementById('chat-container');
            chatContainer.innerHTML = ''; // Clear current display
            chatHistory.forEach(msg => displayMessage(msg));
             // Ensure scroll to bottom after loading history
             chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function toggleSettings() {
            const settingsPanel = document.getElementById('settings-panel');
            const toggleButton = document.getElementById('settings-toggle-button');
            const isHidden = settingsPanel.style.display === 'none' || settingsPanel.style.display === '';
            settingsPanel.style.display = isHidden ? 'block' : 'none';
            toggleButton.textContent = isHidden ? '设置选项 ▼' : '设置选项 ▲';
             // Scroll chat to bottom if settings panel is hidden, just in case
             if (!isHidden) {
                 const chatContainer = document.getElementById('chat-container');
                 chatContainer.scrollTop = chatContainer.scrollHeight;
             }
        }

        function populateModelSelect() {
            const modelSelect = document.getElementById('model-select');
            const currentValue = modelSelect.value; // Keep current selection if possible
            modelSelect.innerHTML = ''; // Clear existing options

            // Ensure availableModels and favoriteModels are ready
            if (!availableModels || availableModels.length === 0) {
                 const option = document.createElement('option');
                 option.value = '';
                 option.textContent = '加载模型失败或无可用模型';
                 option.disabled = true;
                 modelSelect.appendChild(option);
                 return;
            }

            // Separate favorites and others
            const favoriteModelsData = availableModels.filter(model => favoriteModels.includes(model.id));
            const otherModelsData = availableModels.filter(model => !favoriteModels.includes(model.id));

            // Sort models alphabetically by ID
            favoriteModelsData.sort((a, b) => a.id.localeCompare(b.id));
            otherModelsData.sort((a, b) => a.id.localeCompare(b.id));

            if (favoriteModelsData.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = '收藏模型';
                 favoriteModelsData.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    // Use model.name if available, otherwise model.id
                    option.textContent = model.name ? `${model.name} (${model.id})` : model.id;
                    optgroup.appendChild(option);
                });
                modelSelect.appendChild(optgroup);
            }

             if (otherModelsData.length > 0) {
                 const optgroup = document.createElement('optgroup');
                 optgroup.label = '其他模型';
                 otherModelsData.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                     option.textContent = model.name ? `${model.name} (${model.id})` : model.id;
                    optgroup.appendChild(option);
                });
                modelSelect.appendChild(optgroup);
            }


            // Restore previous selection or select a default
            if (currentValue && availableModels.some(model => model.id === currentValue)) {
                 modelSelect.value = currentValue;
            } else if (favoriteModelsData.length > 0) {
                modelSelect.value = favoriteModelsData[0].id;
            } else if (otherModelsData.length > 0) {
                 modelSelect.value = otherModelsData[0].id;
            } else {
                 modelSelect.value = ''; // No models available
            }
        }

        function renderFavoritesList() {
            const favoritesListDiv = document.getElementById('favorites-list');
            favoritesListDiv.innerHTML = ''; // Clear existing list

             if (!availableModels || availableModels.length === 0) {
                 favoritesListDiv.textContent = '无可用模型';
                 return;
             }

             // Sort available models by ID for consistent display
             const sortedAvailableModels = [...availableModels].sort((a, b) => a.id.localeCompare(b.id));

            sortedAvailableModels.forEach(model => {
                const modelDiv = document.createElement('div');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                // Sanitize ID for element ID, replace non-alphanumeric except hyphen/underscore
                checkbox.id = `fav-${model.id.replace(/[^a-zA-Z0-9_-]/g, '')}`;
                checkbox.value = model.id;
                checkbox.checked = favoriteModels.includes(model.id);
                checkbox.addEventListener('change', handleFavoriteChange);

                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = model.name ? `${model.name} (${model.id})` : model.id;

                modelDiv.appendChild(checkbox);
                modelDiv.appendChild(label);
                favoritesListDiv.appendChild(modelDiv);
            });

             // Update model selection dropdown after rendering favorites
            populateModelSelect();
        }

        function handleFavoriteChange(event) {
            const modelId = event.target.value;
            if (event.target.checked) {
                if (!favoriteModels.includes(modelId)) {
                    favoriteModels.push(modelId);
                }
            } else {
                favoriteModels = favoriteModels.filter(id => id !== modelId);
            }
            saveFavorites();
             // Update model selection dropdown after changing favorites
            populateModelSelect();
        }

        function showStatus(message, isError = false) {
            const statusArea = document.getElementById('status-area');
            statusArea.textContent = message;
            statusArea.className = 'status-area'; // Reset classes
            if (isError) {
                statusArea.classList.add('error');
            }
            statusArea.style.display = 'block';
             // Don't auto-hide errors
             if (!isError) {
                  // Auto-hide success/loading status after a few seconds
                 setTimeout(hideStatus, 3000); // Hide after 3 seconds
             }
        }

         function hideStatus() {
             document.getElementById('status-area').style.display = 'none';
         }


        // --- API Interaction ---

        async function fetchModels() {
            showStatus("正在获取可用模型列表...");
            try {
                const response = await fetch(`${WORKER_API_BASE}/models`);

                 if (!response.ok) {
                     // Try to parse JSON error even on non-200 status
                      const errorBody = await response.json().catch(() => null);
                      let errorMessage = `HTTP 错误: 状态码 ${response.status}.`;
                      if (response.status === 403) {
                          errorMessage = "获取模型列表失败: 后端拒绝了请求，请检查 worker 的 ALLOWED_ORIGIN 配置。";
                      } else if (errorBody && errorBody.error && errorBody.error.message) {
                           errorMessage = `获取模型列表失败: ${errorBody.error.message}`;
                      } else if (errorBody && errorBody.message) {
                           errorMessage = `获取模型列表失败: ${errorBody.message}`;
                      } else {
                            errorMessage += ` 响应: ${await response.text().catch(() => '无法读取响应')}`;
                      }
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                // Assuming the worker returns an array of model objects { id: string, name?: string }
                availableModels = data;
                console.log("Available models:", availableModels);

                if (availableModels.length === 0) {
                    showStatus("未获取到可用模型列表，请检查后端配置和API密钥。", true);
                     return;
                }

                hideStatus(); // Hide status if successful

                // Populate UI elements
                renderFavoritesList(); // Renders checkboxes and updates dropdown
                // populateModelSelect() is called inside renderFavoritesList

            } catch (error) {
                console.error("Failed to fetch models:", error);
                showStatus(`获取模型列表失败: ${error.message}.`, true);
                availableModels = []; // Clear models if fetching fails
                populateModelSelect(); // Clear options in dropdown
                renderFavoritesList(); // Clear favorites list UI
            }
        }

        async function sendMessage() {
            const input = document.getElementById('message-input');
            const sendButton = document.getElementById('send-button');
            const messageText = input.value.trim();

            if (!messageText) return;

            // Get selected model and parameters
            const modelSelect = document.getElementById('model-select');
            const selectedModel = modelSelect.value;
             if (!selectedModel || !availableModels.some(model => model.id === selectedModel)) {
                 showStatus("请先选择一个有效的模型。", true);
                 return;
             }

            const temperature = parseFloat(document.getElementById('temperature').value);
            const maxTokens = parseInt(document.getElementById('max-tokens').value, 10);

            // Add user message to history and display
            const userMessage = { role: 'user', content: messageText, timestamp: Date.now() };
            chatHistory.push(userMessage);
            displayMessage(userMessage);
            saveChatHistory();

            // Clear input, reset textarea height, and disable button
            input.value = '';
            autoResizeTextarea(); // Reset height after clearing
            sendButton.disabled = true;
            showStatus(`使用 ${selectedModel} 模型思考中...`);

            try {
                // Prepare message history for the API call
                // Use a common pattern: system message (optional), then alternating user/assistant messages.
                // The last few messages are most relevant for context.
                // We'll send the last N messages, making sure it starts with a user message if possible.
                const HISTORY_LIMIT = 20; // Send last 20 messages, adjust as needed
                // Filter out error messages from history sent to API
                const filteredHistory = chatHistory.filter(msg => !msg.content.startsWith('[错误]'));
                let messagesToSend = filteredHistory.slice(-HISTORY_LIMIT);

                 // Optional: Add a system message if needed by the API or your workflow
                 // messagesToSend.unshift({ role: 'system', content: 'You are a helpful assistant.' });


                const response = await fetch(`${WORKER_API_BASE}/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Origin': window.location.origin // Explicitly send origin
                    },
                    body: JSON.stringify({
                        model: selectedModel,
                        messages: messagesToSend,
                        temperature: temperature,
                        max_tokens: maxTokens,
                        // Add other parameters if needed/supported by the worker/API
                    })
                });

                 if (!response.ok) {
                     const errorBody = await response.json().catch(() => null); // Try to parse JSON error body
                     let errorMessage = `模型请求失败: 状态码 ${response.status}.`;

                     if (response.status === 401 || response.status === 403) {
                         errorMessage = "API 密钥无效、权限不足或后端拒绝了请求（请检查 worker 的 ALLOWED_ORIGIN）。";
                     } else if (response.status === 429) {
                         errorMessage = "模型额度可能已用尽或请求频率过高。请稍后再试或检查您的账户。";
                     } else if (errorBody && errorBody.error && errorBody.error.message) {
                         errorMessage = `模型请求失败: ${errorBody.error.message}`;
                     } else if (errorBody && errorBody.message) { // For Gemini direct errors etc.
                          errorMessage = `模型请求失败: ${errorBody.message}`;
                     } else {
                           errorMessage += ` 响应: ${await response.text().catch(() => '无法读取响应')}`;
                     }

                    throw new Error(errorMessage);
                }

                const data = await response.json();
                console.log("API response:", data);

                // Assuming the worker returns data in a format similar to OpenAI chat completions
                // e.g., { choices: [{ message: { role: 'assistant', content: '...' } }] }
                // Or potentially Gemini direct format: { candidates: [{ content: { parts: [{ text: '...' }] } }] }
                const assistantMessageContent = data.choices?.[0]?.message?.content || data?.candidates?.[0]?.content?.parts?.[0]?.text || "获取回复失败。模型返回了未知格式的响应。";

                const assistantMessage = { role: 'assistant', content: assistantMessageContent, timestamp: Date.now() };
                chatHistory.push(assistantMessage);
                displayMessage(assistantMessage);
                saveChatHistory();
                hideStatus(); // Hide status on success

            } catch (error) {
                console.error("Error sending message:", error);
                // Display error message in the chat
                 const errorMessage = { role: 'assistant', content: `[错误] ${error.message}`, timestamp: Date.now() };
                 displayMessage(errorMessage); // Display the error message bubble
                 chatHistory.push(errorMessage); // Add error message to history
                 saveChatHistory();
                 showStatus(`发送消息失败: ${error.message}`, true); // Also show in status area

            } finally {
                // Re-enable input and button
                sendButton.disabled = false;
                 // Keep error status visible, hide success status after a delay (handled in showStatus)
            }
        }

        // --- Textarea Auto-resize ---
         function autoResizeTextarea() {
            const input = document.getElementById('message-input');
            input.style.height = 'auto'; // Reset height first to get accurate scrollHeight
             const scrollHeight = input.scrollHeight;
             // Ensure minHeight is respected (e.g., 40px from CSS, minus padding/border)
             const minHeight = parseFloat(getComputedStyle(input).minHeight);
             const padding = parseFloat(getComputedStyle(input).paddingTop) + parseFloat(getComputedStyle(input).paddingBottom);
             const border = parseFloat(getComputedStyle(input).borderTopWidth) + parseFloat(getComputedStyle(input).borderBottomWidth);
             const effectiveMinHeight = minHeight - padding - border;

            input.style.height = Math.max(scrollHeight, effectiveMinHeight + padding + border) + 'px'; // Apply height, ensuring it's at least min height

         }


        // --- Initialization and Event Listeners ---

        document.getElementById('send-button').addEventListener('click', sendMessage);
        document.getElementById('message-input').addEventListener('input', autoResizeTextarea); // Auto-resize on input
        document.getElementById('message-input').addEventListener('keypress', function(event) {
            // Send message on Enter key (unless Shift is held for new line)
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent default Enter behavior (new line)
                sendMessage();
            }
        });

        // Initial load
        window.addEventListener('load', () => {
            loadChatHistory();
            clearOldMessages(); // Ensure old messages are cleared before display
            displayChatHistory(); // Display history
            loadFavorites();
            fetchModels(); // Fetch models and populate UI
            // toggleSettings(); // Hide settings panel initially (it's hidden by default CSS)
            autoResizeTextarea(); // Set initial height

             // Periodically clean old messages (e.g., once an hour if the page is open)
             // Be mindful of performance if the history is huge.
             setInterval(clearOldMessages, 60 * 60 * 1000); // Every hour
        });

    </script>

</body>
</html>
